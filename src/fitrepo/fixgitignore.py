#!/usr/bin/env python3
"""
A targeted tool for fixing .gitignore tracking issues in monorepo subdirectories
"""

import os
import sys
import subprocess
import argparse
import logging
from pathlib import Path

logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger()

def run_command(cmd, check=True, capture_output=False, text=False, cwd=None):
    """Run a command with unified error handling."""
    try:
        logger.debug(f"Running: {' '.join(cmd)}")
        return subprocess.run(cmd, check=check, capture_output=capture_output, text=text, cwd=cwd)
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {e}")
        if hasattr(e, 'stderr') and e.stderr:
            logger.error(f"Error output: {e.stderr}")
        raise

def fix_gitignore_tracking(target_dir='.'):
    """
    Fix for .gitignore tracking issue in Git monorepo subdirectories.
    
    Args:
        target_dir: Directory to fix (default: current directory)
    """
    target_path = Path(target_dir).resolve()
    gitignore_path = target_path / '.gitignore'
    
    if not gitignore_path.exists():
        logger.info(f"No .gitignore file found in {target_path}, creating an empty one")
        with open(gitignore_path, 'w') as f:
            f.write("# Auto-generated by fitrepo\n")
    
    logger.info("Fixing .gitignore tracking...")
    
    # Step 1: Configure Git to not show advice about sparse paths
    run_command(['git', 'config', 'advice.updateSparsePath', 'false'], 
                cwd=target_path, check=False)
    
    # Step 2: Force Git to recognize .gitignore using update-index
    logger.info("Adding .gitignore directly to the Git index...")
    run_command(['git', 'update-index', '--add', '.gitignore'], 
                cwd=target_path, check=False)
    
    # Step 3: Alternative approach - use git add with force
    logger.info("Using git add with --force option...")
    run_command(['git', 'add', '--force', '.gitignore'], 
                cwd=target_path, check=False)
    
    # Step 4: Reset to keep .gitignore in index but unstaged
    logger.info("Resetting staging area while keeping .gitignore in the index...")
    run_command(['git', 'reset'], cwd=target_path)
    
    # Step 5: One more direct approach - disable sparse checkout temporarily
    sparse_checkout = False
    git_dir = None
    
    try:
        # Check if sparse checkout is enabled
        result = run_command(['git', 'config', 'core.sparseCheckout'],
                           cwd=target_path, capture_output=True, text=True, check=False)
        sparse_checkout = result.returncode == 0 and result.stdout.strip() == 'true'
        
        # Find .git directory
        if sparse_checkout:
            git_link_path = target_path / '.git'
            if git_link_path.is_file():
                with open(git_link_path, 'r') as f:
                    gitdir_line = f.read().strip()
                    if gitdir_line.startswith('gitdir: '):
                        git_dir = Path(gitdir_line[8:])
                        
                        # Temporarily disable sparse checkout
                        logger.info("Temporarily disabling sparse checkout...")
                        run_command(['git', 'config', 'core.sparseCheckout', 'false'], 
                                  cwd=target_path)
                        
                        # Add and reset again
                        run_command(['git', 'add', '--force', '.gitignore'], 
                                  cwd=target_path, check=False)
                        run_command(['git', 'reset'], cwd=target_path)
    except Exception as e:
        logger.warning(f"Error during sparse checkout handling: {e}")
    
    # Step 6: Re-enable sparse checkout if it was enabled
    if sparse_checkout and git_dir:
        logger.info("Re-enabling sparse checkout...")
        run_command(['git', 'config', 'core.sparseCheckout', 'true'], 
                  cwd=target_path, check=False)
    
    # Step 7: Verify the fix worked
    status_output = run_command(['git', 'status', '-s'], 
                              cwd=target_path, capture_output=True, text=True).stdout
    
    if '.gitignore' not in status_output:
        logger.info("âœ“ Success! .gitignore is now properly tracked.")
    else:
        logger.warning(".gitignore is still showing in git status output.")
        logger.info("You may need to commit .gitignore manually or try additional Git commands.")
    
    logger.info("Run 'git status' to verify the fix.")

def main():
    parser = argparse.ArgumentParser(description='Fix .gitignore tracking issues in Git repositories')
    parser.add_argument('directory', nargs='?', default='.', help='Target directory (default: current directory)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    try:
        fix_gitignore_tracking(args.directory)
        return 0
    except Exception as e:
        logger.error(f"Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == "__main__":
    sys.exit(main())
